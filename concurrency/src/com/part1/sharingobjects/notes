volatile变量：
当一个域声明为volatile类型后，编译器与运行时会监视这个变量：
它是共享的，而且对它的操作不会与其它的内存操作一起被重排序

只有当volatile变量能够简化实现和同步策略的验证时，才使用它们。
当验证正确性必须推断可见性问题时，应该避免使用volatile变量

正确的使用volatile变量的方式：
用于确保他们所引用的对象状态的可见性，
用于标识重要的生命周期事件(比如初始化和关闭)的发生。

volatile的语义不足以使自增操作(a++)原子化。

加锁可以保证可见性和原子性；



只有满足下面所有的标准后，才能使用volatile变量：
写入变量时并不依赖变量的当前值；或者能够确保只有单一的线程修改变量的值；
变量不需要与其它的状态变量共同参与不变约束；
而且，访问变量时，没有其它的原因需要加锁。

发布：
发布一个对象的意思是使它能够被当前范围之外的代码所使用。
发布对象的方式：
1、将对象的引用存储到公共静态域中。public  static
2、从非私有的方法中返回引用（不建议使用 破坏了数据的封装性）




线程封闭：

访问共享的、可变的数据要求使用同步；一个避免同步的方式就是不共享数据。
Swing发展了线程封闭技术。
应用池化的JDBCConnection对象；JDBC规范并没有要求Connection对象是线程安全的。然而在典型的服务器应用中
，线程总是从池中获得一个Connection对象，并且用它处理一个单一的请求，最后把它归还。每个线程都会同步地
处理大多数请求，而且在Connection对象被归还之前池不会将它再分配给其他线程，因此，这种连接管理模式隐式
的将Connection对象限制在处于请求处理期间的线程中。

Ad-hoc线程限制：指未经过设计而得到的线程封闭行为。
栈限制：在栈限制中只能通过本地变量才可以触及对象。
ThreadLocal：允许将每个线程与特有数值的对象关联在一起。
			 ThreadLocal提供了get与set访问器，为每个使用它的线程维护一份单独的拷贝。所以get总是返回当前执行线程通过set设置的最新值。


不可变性：（不可变对象永远是线程安全的）

只有满足如下状态，一个对象才是不可变的：
-它的状态不能在创建后再被修改。
-所有域都是final类型
-它被正确创建（创建期间没有发生this引用的逸出）

“对象是不可变的”和“到对象大的引用是不可变的”两者不等价。


安全发布：
为了安全的发布对象，对象的引用以及对象的状态必须同时对其他线程可见，一个正确创建的对象可以通过下列条件安全的发布
 1、 通过静态初始化器初始化对象的引用：public static Student student = new Student();
 2、将它的引用存储到volatile域或AtomicReference；
 3、将它的引用存储到正确创建的对象的final域中
 4、或者将它的引用存储到由锁正确保护的域中
 
 
高效不可变对象
 一个对象在技术上不是不可变的，但是它的状态不会再发布后被修改，这样的对象称作有效不可变对象。
 这种对象不必满足不可变性的约束条件；这些对象发布后程序只简单的把它们当作不可变对象
 
 任何线程对象都可以在没有额外的同步下安全地使用一个安全发布的高效不可变对象。
 
 可变对象
 为了保证安全地共享可变对象，可变对象必须是被安全发布的，同时必须是线程安全的或者是被锁保护的。
 
 发布对象的必要条件依赖于对象的可变性：
 1、不可变对象可以通过任意机制发布
 2、高效不可变对象必须要安全发布
 3、可变对象必须要安全发布，同时必须要线程安全或者是被锁保护。
 
 
在并发程序中，使用和共享对象的一些最有效的策略如下：
 1、线程限制：一个线程限制的对象，通过限制在线程中，而被线程独占，且只能被占有它的线程修改。
 2、共享只读：一个共享的只读对象，在没有额外同步的情况下可以被多个线程并发地访问，但是任何线程都不能修改它。共享只读对象包括可变对象与高效不可变对象。
 3、共享线程安全：一个线程安全的对象在内部进行同步，所以其他线程无须额外同步，就可以通过公共接口随意的访问它
 4、被守护的：一个被守护的对象只能通过特定的锁来访问。被守护的对象包括吗谢谢被线程安全对象封装的对象，和已知被特定的锁保护起来的已发布对象。